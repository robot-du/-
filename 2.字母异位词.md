# 字母异位词


**题目**
给你一个字符串数组，请你将 __字母异位词__ 组合在一起。可以按任意顺序返回结果列表。


**示例**
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
解释：
在 strs 中没有字符串可以通过重新排列来形成 "bat"。
字符串 "nat" 和 "tan" 是字母异位词，因为它们可以重新排列以形成彼此。
字符串 "ate" ，"eat" 和 "tea" 是字母异位词，因为它们可以重新排列以形成彼此。

示例 2:
输入: strs = [""]
输出: [[""]]

示例 3:
输入: strs = ["a"]
输出: [["a"]]


**代码**
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 创建哈希表：key是排序后的字符串，value是原始字符串数组
        unordered_map<string, vector<string>> m;

        for (auto& x : strs) {
            string sorted = x;          // 复制原字符串
            sort(sorted.begin(), sorted.end());  // 对复制的字符串排序
            m[sorted].push_back(x);     // 以排序后的字符串为key，添加原字符串
        }

        vector<vector<string>> ans;     // 存储最终结果
        for (auto& x : m) {
            ans.push_back(x.second);    // 将每个分组加入结果
        }

        return ans;
    }
};


**复杂度分析**
时间复杂度：O(nmlogm)，其中 n 为 strs 的长度，m 为 strs[i] 的长度。每个字符串排序需要 O(mlogm) 的时间，有 n 个字符串，所以总的时间复杂度O(nmlogm)。
空间复杂度：O(nm)。


**解释**
两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。
遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。